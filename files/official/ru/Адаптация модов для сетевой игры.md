# Адаптация модов для сетевой игры

## Декларация

Чтобы задекларировать мод, как поддерживающий игру в мультиплеере, в скрипте запуска `launcher.js` перед вызовом `Launch(...)` нужно вызвать метод `ConfigureMultiplayer(configuration)`. При вызове данного метода можно указать параметры name и version, которые будут использованы для идентификации мода в сетевой игре. Если какой то из этих параметров не указан, то он будет взят из `mod.info`. Кроме того если присутствует параметр `isClientOnly: true`, мод будет задекларирован как чисто клиентский, клиенские моды не должны влиять на мир и не будут учитываться при синхронизации модов при подключении (примеры: MiniMap, Recipe Viewer, WAILA).

```js
ConfigureMultiplayer({
    name: "readable unique name", // уникальное сетевое имя мода
    version: "version", // версия
    isClientOnly: true/false // если true, мод считается сугубо клиентским
});
```

## Общие понятия

Для того, чтобы корректно работать в сетевой игре, код мода должен быть разделен на клиентскую и серверную часть, которые не взаимодействуют друг с другом никак, кроме сетевых пакетов и событий сетевых сущностей. Это значит что клиентская часть мода не может использовать переменные, функции и т.п. серверной части и наоборот.

Серверная часть должна отвечать за всю логику и работу с миром, в то время как клиентская часть отвечает за визуальную часть на основе данных с сервера и отправкой пользовательских действий на сервер.

Однако многие стандартные объекты, такие как Tile Entity, контейнеры, броня и т.п. уже адаптированы под сетевую игру, если использовать новый API.

В случае загрузки своего мира на одном и том же устройстве запускается сервер и подключенный к нему клиент. При подключении к миру запускается клиент, подключенный к серверу, запущенного у хоста.

## Передача и обработка сетевых пакетов

Базовый сетевой функционал строится на передаче пакетов - именованных данных, от клиентов к серверу и обратно. Чтобы принимать пакеты с определенным именем для сервера или клиента можно зарегестрировать событие, которое будет вызываться каждый раз, когда приходит пакет с соответствующим именем.

```js
// событие сработает, когда на клиент придет пакет testMod.serverMessage
Network.addClientPacket("testMod.serverMessage", function(packetData) {
    // мы знаем, что приходит объект вида {sender: ..., text: ...}
    Game.message("[" + packetData.sender + "] " + packetData.text);
});

// функция, отправляющая сообщение всем игрокам
function sendMessageToAll(sender, text) {
    // отправить пакет всем клиентам testMod.serverMessage
    Network.sendToAllClients("testMod.serverMessage", {
        sender: sender,
        text: text
    });
}
```

Аналогичным образом можно отправлять пакеты с клиента на сервер.

```js
// событие получение сервером пакета testMod.clientMessage от клиента
Network.addServerPacket("testMod.clientMessage", function(client, data)) {
    // отправить сообщение всем клиентам, отправителем указать игрока, от которого пришло сообщение
    sendMessageToAll(client.getPlayerUid(), data.text);
});

// функция клиента, отправляющая сообщение игрока серверу, который потом пошлет его всем игрокам от его имени
function sendMessageFromClient(message) {
    // отправить пакет с клиента на сервер
    Network.sendToServer("testMod.clientMessage", {text: message});
}
```

В случае последнего примера мы можем видеть, что в событие получения сервером пакета приходит параметр client, который является серверным интерфейсом клиента, от которого получен данный пакет. С помощью него можно получить сущность игрока (`client.getPlayerUid()`). Кроме того он позволяет отправлять пакеты конкретному клиенту, а не всем сразу. Чтобы получить клиента, зная сущность игрока, нужно использовать `Network.getClientForPlayer(playerUid)`.

```js
// зарегистрировать функцию использования для палки
Item.registerUseFunctionForID(280, function(coords, item, block, player) {
    // получить интерфейс клиента для использующего игрока
    var client = Network.getClientForPlayer(player);
    // обязательно проверить, что он существует
    if (client != null) {
        // отправить конкретно этому клиенту сообщение
        client.send("testMod.serverMessage", {
            sender: "server debug", // отправитель - серверная отладка
            text: "you just used stick!" // просто текст
        });
    }
});
```

## Конвертация ID блоков и предметов

Числовые ID одних и тех же блоков и предметов скорее всего будут разными на клиенте и на сервере. Inner Core автоматически синхронизирует ID так, что на разных устройствах один и тот же предмет будет иметь разные ID. Однако при передаче их в виде чисел с помощью пакетов они будут различны и их придется конвертировать вручную.

По скольку клиентов много, а сервер один, конвертация происходит на стороне клиента, для этого существуют функции `Network.serverToLocalId(id)` и `Network.localToServerId(id)`, конвертирующие серверный ID в клиентский и обратно.

Рассмотрим пример, демонстрирующий это:

```js
// пакет, приходящий на клиент от сервера, с информацией об использовании предмета (для примера передаем только id и data)
Network.addClientPacket("testMod.useItemInfo", function() {
    // выведем информацию: сначала id, который прислал нам сервер, потом id, который этот предмет имеет на клиенте, чтобы подтвердить, что на клиенте это тот самый предмет, получим его имя по id клиента
    var localId = Network.serverToLocalId(packetData.id);
    Game.message("you just used item: server=" + packetData.id + " client=" + localId + " name=" + Item.getName(localId, packetData.data));
});

// серверное событие использования предмета
Callback.addCallback("ItemUse", function(coords, item, block, isExternal, player) {
    var client = Network.getClientForPlayer(player);
    if (client != null) {
        // отправим пакет с данными предмета, по скольку событие чисто серверное, это будет серверный id предмета
        client.send("testMod.useItemInfo", {id: item.id, data: item.data});
    }
});
```

Для того, чтобы проверить этот пример на практике, нужно два устройства, потому что у пары клиента и сервера, которые запускаются на одном устройстве, id будут одинаковые. Чтобы форсировать разные id на двух устройствах, можно попробовать изменять файл innercore/mods/.staticid

## Адаптация Tile Entity

Основная логика Tile Entity работает на серверной стороне. Однако можно декларировать отдельный прототип для клиента. По этому прототипу будет создаваться экземпляр у клиентов, которые имеют данный Tile Entity рядом, имеет события появления, тика и уничтожения, что позволяет добавить визуальную составляющую.

По скольку старый контейнер, который использовался Tile Entity ранее, не поддерживает мультиплеер, чтобы Tile Entity поддерживал сетевую игру, его нужно перенести на новый тип контейнера - `ItemContainer`. Новый тип контейнера совместим со старыми сохранениями.

Далее приведена документация по сетевому прототипу Tile Entity, события, которые тут опущенны, относятся к серверной стороне.

```js
{
    // прототип серверной стороны

    useNetworkItemContainer: true, // разрешить использования контейнера с поддержкой сетевой игры

    defaultValues: {
        // сохраняемые значения
    },

    // инициализация
    init: function() {
        // Внутри серверного Tile Entity доступны следующие поля:
        // this.x, this.y, this.z, this.dimension - координаты и измерение
        // this.data - все сохраняемые значения
        // this.container - объект ItemContainer
        // this.blockSource - объект BlockSource для доступа к измерению, в котором находится данный Tile Entity
        // this.networkData - объект SyncedNetworkData синхронизированые данные, доступные всем клиентам
        // this.networkEntity - объект NetworkEntity, представляющий сетевую сущность, на основе которого работает данный Tile Entity, нужен только для продвинутых операций, обычно не требуется

        // Сетевые методы
        // this.sendPacket("eventName", data) - отправляет пакет всем клиентским экземплярам этого Tile Entity
    },

    // это событие вызывается на серверной стороне и возвращает имя интерфейса, который нужно открыть при клике
    getScreenName: function(player, coords) {
        return "someName";
    },

    // это событие вызывается на стороне клиента, this в данном случае не определен, по переданному имени, которое вернул метод getScreenName, возвращает окно, которое нужно открыть
    getScreenByName: function(screenName) {
        return someGuiWindow;
    },

    client: {
        // прототип экземпляра клиентского Tile Entity, экземпляр создается на каждого клиента, каждый раз, когда Tile Entity становится видно на стороне клиента и уничтожается каждый раз, когда его становится не видно.

        // вызывается при создании экземпляра
        load: function() {
            // Внутри клиентского Tile Entity доступны следующие поля:
            // this.x, this.y, this.z, this.dimension - координаты и измерение
            // this.networkData - объект SyncedNetworkData синхронизированые данные, доступные всем клиентам
            // this.networkEntity - объект NetworkEntity, представляющий сетевую сущность, на основе которого работает данный Tile Entity, нужен только для продвинутых операций, обычно не требуется

            // контейнер и доступ к миру не доступны на стороне клиента

            // Сетевые методы
            // this.sendPacket("eventName", data) - отправляет пакет серверному экземпляру Tile Entity
        },

        // вызывается при уничтожении экземпляра
        unload: function() {

        },

        // вызывается каждый тик на локальном потоке, стоит учесть, нагрузки на локальном потоке больше сказываются на производительности
        tick: function() {

        },

        events: {
            // события, принимающие пакеты на стороне клиента, в данном случае this будет клиентским экземпляром, получившим этот пакет
            packetName: function(packetData, packetExtra) {

            }
        },

        containerEvents: {
            // события клиентского экземпляра контейнера, this не определен
            // эти события предназначены для редактирования содержимого окна
            eventName: function(container, window, windowContent, eventData) {
                // window и windowContent могут быть null
                // Чтобы отправить данные на сервер container.sendEvent("eventName", someData)
            }
        }
    },

    events: {
        // события, принимающие пакеты на стороне сервера, в данном случае this - серверный экземпляр, получивший пакет
        packetName: function(packetData, packetExtra, connectedClient) {
            // доступный только здесь метод, отправляет пакет конкретному клиенту: this.sendResponse("packetName", someData)
        }
    },

    containerEvents: {
        // события контейнера на стороне сервера, в данном случае this - серверный экземпляр, получивший пакет

        eventName: function(eventData, connectedClient) {
            // доступный только здесь метод: this.container.sendResponseEvent("eventName", someData)
        }
    }
}
```

Рассмотрим несколько примеров, начиная с самого простого. В примерах будет отсутствовать объявление окна интерфейса, так как изменений в этой области не требуется, переменная, содержащая его, будет называться `guiExample`.

Пример простейшего Tile Entity с интерфейсом и базовой логикой контейнера.

```js
{
    useNetworkItemContainer: true, // использовать сетевой контейнер

    getScreenName: function(player, coords) {
        // мы имеем только один вариант интерфейса, назовем его "main"
        return "main";
    },

    getScreenByName: function(screenName) {
        // мы имеем только интерфейс с именем "main"
        return screenName == "main" ? guiExample : null;
        // кроме того возможен вариант без проверки имени:
        return guiExample;
    },

    tick: function() {
        // в серверном тике произведем базовую логику над контейнером:
        if (World.getThreadTime() % 20 == 0) {
            var slot = this.container.getSlot("someSlot");
            if (slot.id == 264) {
                // применять изменения слота нужно через setSlot, чтобы контейнер зарегистрировал их, просто изменение полей объекта (slot.count--) не будет считаться
                this.container.setSlot("someSlot", slot.id, slot.count - 1, slot.data, slot.extra);
                // валидация слота: если количество равно 0, очистить слот
                this.container.validateSlot("someSlot");
                // тут можно произвести какую то другую серверную логику
            }
        }
        // отправить все изменения контейнера клиентам, чтобы они отобразить актуальное содержимое, данная функция отправляет только измененные слоты и значения, что происходит быстро, потому ее можно вызывать в конце каждого тика, если в нем могли произойти изменения на стороне сервера
        this.container.sendChanges();
    }
}
```

Теперь рассмотрим использование сетевых событий Tile Entity. Следующий пример демонстрирует использование прототипа клиента и сетевых событий для создания анимаций из частиц и является продолжением прошлого (будут показаны только места, которые надо дополнить).

```js
{
    ...
    client: {
        // добавим прототип клиента, который будет отвечать за анимации
        events: {
            // событие, принимающее пакет animateParticles
            animateParticles: function(packetData) {
                // создать частицы огня в количестве packetData.power
                for (var i = 0; i < packetData.power; i++) {
                    Particles.addParticle(7, this.x + .5, this.y + .5, this.z + .5, Math.random() - .5, Math.random() - .5, Math.random() - .5, 0);
                }
            }
        }
    }

    tick: function() {
        ...
        if (slot.id == 264) {
            ...
            // при успешной операции отправить событие анимации всем клиентам
            this.sendPacket("animateParticles", {power: 100});
        }
        ...
    }
}
```

## Работа с миром и BlockSource

По скольку в игре по сети (и на самом деле в некоторых случаях в одиночной игре) требуется одновременно осуществлять доступ к нескольким измерениям одновременно, на смену работе с миром через модуль `World` приходит `BlockSource` - объект региона, который позволяет осуществлять доступ к блокам и мобам конкретного измерения.

> *ВАЖНО!* Работа через модуль `World` где либо, кроме событий генерации мира скорее всего приведет к некорректному поведению, если игроки находятся в разных измерениях. Во время генерации методы из модулей `World` и `GenerationUtils` всегда работают в правильном измерении.

### Основные методы

- `int getDimension()` - возвращает id измерения, к которому относится данный объект
- `int getBlockId(x, y, z)` - получает id блока по координатам
- `int getBlockData(x, y, z)` - получает метоаданные блока по координатам
- `void setBlock(x, y, z, id, data)` - устанавливает блок на координаты
- `NativeTileEntity getBlockEntity(x, y, z)` - возвращает интерфейс к ванильному Tile Entity (сундук, печка и т.п.)
- `int getBiome(x, z)` - возвращает id биома по координатам
- `void setBiome(x, z, id)` - устанавливает id биома по координатам
- `float getBiomeTemperatureAt(x, y, z)` - возвращает температуру биома по координатам
- `boolean isChunkLoaded(chunkX, chunkZ)` - возвращает, загружен ли чанк по координатам чанка
- `boolean isChunkLoadedAt(x, z)` - возвращает, загружен ли чанк по координатам блока
- `int getChunkState(chunkX, chunkZ)` - возвращает состояние загрузки чанка по координатам чанка
- `int getChunkStateAt(x, z)` - возвращает состояние загрузки чанка по координатам блока
- `boolean canSeeSky(x, y, z)` - возвращает, видно ли небо из данной точки
- `int getGrassColor(x, z)` - возвращает цвет травы
- `void destroyBlock(x, y, z[, drop])` - уничтожает блок на координатах, если `drop` `true`, то блок дропает ресурсы как при уничтожении не игроком
- `void explode(x, y, z, power[, fire])` - производит взрыв на координатах
- `long spawnEntity(x, y, z, int type)` - создает сущность по числовому типу и возвращает
- `long spawnEntity(x, y, z, string type)` - создает сущность по строковому типу и возвращает ее, варианты синтаксиса: `type_name`, `namespace:type_name`, `namespace:type_name:init_data`
- `long spawnEntity(x, y, z, namespace, typeName, initData)` - создает сущность по пространству имен, названию типа и данным инициализации и возвращает ее
- `long spawnDroppedItem(x, y, z, id, count, data[, extra)` - создает выкинутый предмет и возвращает id сущности
- `void spawnExpOrbs(x, y, z, expAmount)` - создает на координатах сферы опыта, общей ценностью `expAmount`
- `long[] listEntititesInAABB(x1, y1, z1, x2, y2, z2[, type[, blacklist]])` - возвращает список id сущностей в заданном параллелепипеде, которые соответствуют данному типу type, если значение `blacklist` `false` и всех, кроме сущностей не этого типа, если `blacklist` `true`

### Методы для произвольного доступа к BlockSource

- `BlockSource.getDefaultForDimension(dimension)` - возвращает интерфейс к данному измерению по умолчанию. Вернет `null`, если данное измерение не загруженно и этот интерфейс еще не был создан.
- `BlockSource.getDefaultForActor(entityUid)` - возвращает интерфейс к измерению, в котором находится сущность, вернет `null`, если сущность не существует или данное измерение не загружено и интерфейс не был создан.

### BlockSource и Tile Entity

Прежде всего с этим объектом мы сталкиваемся в Tile Entity, каждый серверный экземпляр имеет поле `blockSource`, содержащий интерфейс к измерению, в котором он находится. *ВАЖНО!* Вся работа с миром в этом Tile Entity должна происходить через его `BlockSource`.

## Измененные для поддержки сетевой игры события

Многие события теперь принимают id сущности игрока, производящего действие, или объект `BlockSource`, предоставляющий доступ к измерению, где происходит событие.

### Регистрируемые события

- `Item.registerUseFunction` - регистрируемое событие принимает игрока, использующего предмет 4 параметром
- `Item.registerNoTargetUseFunction` - регистрируемое событие принимает игрока, использующего предмет 2 параметром
- `Item.registerUsingReleasedFunction` - регистрируемое событие принимает игрока, использующего предмет 3 параметром
- `Item.registerUsingCompleteFunction` - регистрируемое событие принимает игрока, использующего предмет 2 параметром
- `Item.registerDispenseFunction` - регистрируемое событие принимает игрока, использующего предмет 3 параметром
- `Block.registerDropFunction` - регистрируемое событие принимает 7 параметром объект `BlockSource`
- `Block.registerPlaceFunction` - регистрируемое событие принимает 4 и 5 параметрами игрока и объект `BlockSource`
- `Block.registerPopResourcesFunction` - регистрируемое событие получает объект `BlockSource` 3 параметром
- `Block.setRandomTickCallback` - регистрируемое событие получает объект `BlockSource` 6 параметром
- `Block.registerNeighbourChangeFunction` - регистрируемое событие получает объект `BlockSource` 4 параметром
- `World.registerBlockChangeCallback` - регистрируемое событие получает объект `BlockSource` 4 параметром
- событие TileEntity `click` принимает игрока 5 параметром

### События, добавленные через `Callback.addCallback`

- `ItemUse` - событие принимает игрока, использующего предмет 5 параметром
- `DestroyBlock` - событие принимает сломавшего блок игрока 3 параметром
- `FoodEaten` - событие принимает игрока 3 параметром
- `ExpAdd` - событие принимает игрока 2 параметром
- `ExpLevelAdd` - событие принимает игрока 2 параметром
- `PlayerAttack` - событие принимает игрока 1 параметром
- `EntityInteract` - событие принимает игрока 2 параметром
- `ItemUseNoTarget` - событие принимает игрока 2 параметром
- `ItemUsingReleased` - событие принимает игрока 3 параметром
- `ItemUsingComplete` - событие принимает игрока 2 параметром
- `ExpLevelAdd` - событие принимает игрока 2 параметром
- `RedstoneSignal` - событие принимает объект `BlockSource` 4 параметром
- `PopBlockResources` - событие принимает объект `BlockSource` 5 параметром
- `BlockEventNeighbourChange` - событие принимает объект `BlockSource` 4 параметром
- `ItemDispensed` - событие принимает объект `BlockSource` 3 параметром

## Работа с SyncedNetworkData в Tile Entity

И серверный и клиентский экземпляры Tile Entity имеют поле `networkData`, которое представляет данные, синхронизированные между сервером и всеми клиентами и позволяющий отлавливать их изменения и проверять их.

### Методы обмена данными

- `int getInt(key[, fallback])` - получает значение по ключу
- `long getLong(key[, fallback])` - получает значение по ключу
- `float getFloat(key[, fallback])` - получает значение по ключу
- `double getDouble(key[, fallback])` - получает значение по ключу
- `String getString(key[, fallback])` - получает значение по ключу
- `boolean getBoolean(key[, fallback])` - получает значение по ключу
- `void putInt(key, value)` - устанавливает значение по ключу
- `void putLong(key, value)` - устанавливает значение по ключу
- `void putFloat(key, value)` - устанавливает значение по ключу
- `void putDouble(key, value)` - устанавливает значение по ключу
- `void putString(key, value)` - устанавливает значение по ключу
- `void putBoolean(key, value)` - устанавливает значение по ключу
- `void sendChanges()` - отправить изменившиеся данные

### События

Объекту `SyncedNetworkData` можно добавить событие, отлавливающее изменение каких либо данных, это событие может быть установленно как на стороне сервера (в событии `init` серверного экземпляра Tile Entity), так и на стороне клиента (в событии `load` клиентского экземпляра Tile Entity).

```js
this.networkData.addOnDataChangedListener(function(networkData, isExternalChange) {
    // networkData - объект SyncedNetworkData, в котором произошли изменения
    // isExternalChange - false, если изменение произошло вызовом put из этого объекта, true - если оно пришло по сети из другого присоединенного объекта данных
});
```

Кроме того серверному объекту `SyncedNetworkData` можно добавлять валидаторы - методы, которые проверяют изменение, которое пришло от клиента и могут подтвердить его, изменить или опровергнуть. Это требуется для безопасности, чтобы клиенты не могли отправлять некорректные данные на сервер с помощью модифицированных модов.

Установить валидатор можно в событии `init` серверного экземпляра Tile Entity:

```js
this.networkData.addVerifier(key, function(key, newValue) {
    // валидатор возвращает значение, которое будет установленно в данные
    // чтобы пропустить значение просто используется return newValue;
    // чтобы отменить изменение используется return null;
    // можно вернуть любое другое значение и оно будет установленно
});
```

Если какое то поле в серверных синхронизированных данных надо заблокировать от изменений клиентами, можно сделать это следующим образом:

```js
this.networkData.addVerifier(key, function(key, newValue) { return null; });
```

### Пример

Рассмотрим как пример Tile Entity, который отображает над собой модель предмета, который лежит в его слоте.

```js
{
    // используем сетевую реализацию контейнера
    useNetworkItemContainer: true,

    client: {
        updateModel: function() {
            // обновить модель используя networkData
            // не стоит забывать про конвертацию id предметов из серверных в клиентские
            var id = Network.serverToLocalId(this.networkData.getInt("itemId"));
            var data = this.networkData.getInt("itemData");
            this.model.describeItem({
                id: id, count: 1, data: data, size: 1
            });
        },

        load: function() {
            // создаем модель при создании клиентского экземпляра
            this.model = new Animation.Item(this.x + .5, this.y + 1.5, this.z + .5);
            this.updateModel();
            this.model.load();

            // добавляем событие изменения данных
            var that = this;
            this.networkData.addOnDataChangedListener(function(data, isExternal) {
                // при изменении данных обновить модель
                that.updateModel();
            });
        },

        // уничтожаем модель при уничтожении экземпляра
        unload: function() {
            this.model.destroy();
        }
    },

    tick: function() {
        // обновляем данные раз в 10 тиков, чтобы не нагружать
        if (World.getThreadTime() % 10 == 0) {
            // получаем слот
            var slot = this.container.getSlot("someSlot");
            // передаем данные через networkData
            this.networkData.putInt("itemId", slot.id);
            this.networkData.putInt("itemData", slot.data);
            // посылаем изменения клиентам
            this.networkData.sendChanges();
        }
    }

    // методы открытия интерфейса присутствуют, но для примера не важны
}
```

## Тик игрока и другие события

По скольку многие операции требуется производить для каждого игрока отдельно, введено дополнительное событие `ServerPlayerTick`. Это событие вызывается на стороне сервера каждый тик для каждого игрока. Далее идет пример добавления события:

```js
Callback.addCallback("ServerPlayerTick", function(playerUid, isPlayerDead) {
    // playerUid - сущность игрока
    // isPlayerDead - дополнительный параметр - мертв ли данный игрок
    var client = Network.getClientForPlayer(playerUid);
    if (client != null) {
        // что то сделать
    }
});
```

Кроме этого существует событие тика клиента, которое вызывается каждый тик клиентского потока - `LocalTick`. Все клиентские действия тика должны происходить в нем, в частности пользовательским движением игрока.

```js
Callback.addCallback("LocalTick", function() {
    // локального игрока можно получить через Player.get()
});
```

События `DimensionLoaded` и `DimensionUnloaded` устарели, т.к. не подходят для сетевой игры, на смену им приходит серверное событие `PlayerChangedDimension`, которое вызывается при загрузке игрока в измерении или переходе между измерениями.

```js
Callback.addCallback("PlayerChangedDimension", function(playerUid, currentId, lastId) {
    // playerUid - игрок, сменивший измерение
    // currentId - измерение, в котором сейчас игрок
    // lastId - измерение, в котором игрок был, если это событие вызвалось при загрузке игрока, то currentId == lastId
});
```

## Интерфейс игрока

Серверной стороне требуется обрабатывать разных игроков, по этому модуль `Player` перестает быть актуальным в сетевой игре. На смену ему приходит объект `PlayerActor`, который позволяет создать временный интерфейс игрока.

> *ВАЖНО!* Объект `PlayerActor` является временным и валиден в течении 1 серверного тика, после этого, если игрок отключится, его использование может вызвать краш. Потому каждый тик нужно создавать новый объект. Кроме того

### Пример

```js
Callback.addCallback("ServerPlayerTick", function(playerUid, isPlayerDead) {
    // каждый тик создаем новый интерфейс для последующего использвание
    var player = new PlayerActor(playerUid);
});
```

### Основные методы

- `int getDimension()` - возвращает id измерения, в котором находится игрок
- `int getGameMode()` - возврашает режим игры игрока
- `void addItemToInventory(id, count, data, extra, dropRemainings)` - добавляет предмет в инвентарь, если `dropRemainings` `true` излишки будут выброшены как дроп рядом с игроком
- `ItemStack getInventorySlot(slot)` - возвращает содержимое слота инвентаря
- `void setInventorySlot(slot, id, count, data, extra)` - устанавливает содержимое слота инвентаря
- `ItemStack getArmor(slot)` - возвращает содержимое слота брони
- `void setArmor(slot, id, count, data, extra)` - устанавлиает содержимое слота инвентаря
- `void setRespawnCoords(x, y, z)` - устанавливает координаты спавна
- `void spawnExpOrbs(x, y, z, value)` - спавнит опыт на координатах
- `boolean isValid()` - является ли валидной сущностью

### Геттеры/Сеттеры свойств

- `int getSelectedSlot()`
- `void setSelectedSlot(slot)`
- `void addExperience(amount)`
- `float getExperience()`
- `void setExperience(value)`
- `int getLevel()`
- `void setLevel(level)`
- `float getExhaustion()`
- `void setExhaustion(value)`
- `float getHunger()`
- `void setHunger(value)`
- `float getSaturation()`
- `void setSaturation(value)`
- `int getScore()`
- `void setScore(value)`

## Броня

По скольку старые методы регистрации событий брони не подходили для мультиплеера, добавлены новые функции регистрации, которые приведены далее.

```js
Armor.registerOnTickListener(id, function(item, slot, player) {
    // данное событие вызывается каждый тик для каждого игрока, на которого надета эта броня
    // это событие может возвращать объект вида {id: , count: , data: , extra: }, чтобы изменить предмет брони, если ничего не возвращается, то броня изменена не будет
});
```

```js
Armor.registerOnHurtListener(id, function(item, slot, player, value, type, attacker, bool1, bool2) {
    // данное событие вызывается при нанесении урона игроку, на котором надета броня
    // это событие может возвращать объект вида {id: , count: , data: , extra: }, чтобы изменить предмет брони, если ничего не возвращается, то броня будет повреждена стандартным образом
});
```

```js
Armor.registerOnTakeOnListener(id, function(item, slot, player) {
    // данное событие вызывается когда игрок надевает броню или спавнится с ней
});
```

```js
Armor.registerOnTakeOffListener(id, function(item, slot, player) {
    // данное событие вызывается когда игрок снимает или заменяет этот предмет брони
});
```
