# ПРОДВИНУТОЕ СОЗДАНИЕ БЛОКОВ И ПРЕДМЕТОВ.

!> 本文档是为旧的 Inner Core 1.0 或更旧的 Core Engine 编写的。参阅时请仔细分辨，以免造成不必要的麻烦。

Кроме создания простейших блоков и предметов, Core Engine позволяет настраивать их и добавлять различные события для конкретного блока или предмета.

## СПЕЦИАЛЬНЫЕ ТИПЫ БЛОКОВ

Чтобы создать блок с параметрами, которые отличаются от стандартных (свечение, модель), используются специальные типы блоков. Регистрируются они с помощью функции Block.`createSpecialType(объект характеристик)` - функция принимает объект характеристик, которые нужно изменить и отдает специальный тип блока с этими характеристиками.

Специальный тип, созданный этой функцией передается в функцию `Block.createBlock` и `Block.createBlockWithRotation` третим параметром, чтобы блок был создан для данного специального типа. На 1 специальном типе может быть создано суммарно до 16 вариаций различных блоков.

Все характеристики, их значения по-умолчанию и разъяснение:

```js
{
    base: 20, // блок из MCPE, который будет взят за основу в создании блока, могут быть скопированы некоторые свойства и материал
    opaque: false, // непрозрачность, если true, то внутри блока мобы будут получать урон, а так же места соприкосновения этого блока с другими не будут отрисованы
    rendertype: 0, // тип модели, не работает в 0.15.7 и выше
    renderlayer: 4, // тип рендера, 4 означает, что прозрачные части будут отрисованы прозрачными, а не черными
    destroytime: 1, // не работает в 0.15.0 и выше, время ломания блока
    redstoneconsumer: true, // будет ли происходить событие изменения редстоун-сигнала для этого блока
    lightopacity: 1, // непрозрачность для света, сколько света будет поглощаться при прохождении через этот блок, 0 - полностью прозрачен, 15 - полностью непрозрачен
    lightlevel: 0, // свечение блока, 0 - нет свечения, 15 - максимальное свечение
    explosionres: 2, // взрывоустойчивость
    color: [0xFFFFFF] // цвет для каждой стороны в формате 0xRRGGBB, если в массиве 1 элемент, то цвет будет установлен для всего блока
}
```

Пример создания специального типа блока и самого блока:

```js
var BLOCK_TYPE_LOW_LIGHT = Block.createSpecialType({ // блок этого типа будет абсолютно прозрачен для света и сам будет слабо светиться
    lightlevel: 11,
    lightopacity: 0
});

IDRegistry.genBlockID("testBlock"); // регистрациа id

Block.createBlock("testBlock", [
    {name: "test block", texture: [["obsidian", 0], ["obsidian", 0], ["obsidian", 0], ["obsidian", 0], ["obsidian", 0], ["obsidian", 0]]}
], BLOCK_TYPE_LOW_LIGHT); // создаем блок на данном специальном типе
```

## ФУНКЦИЯ ДРОПА (ЛОМАНИЯ):

К конкретному блоку можно привязать функцию дропа, которая выполняется при ломании блока с данным id. Делается это с помощью функций `Block.registerDropFunction("строковый id блока", функция дропа)` и `Block.registerDropFunctionForID(числовой id блока, функция дропа)`

Функция дропа имеет такой формат:

```js
function(coords, id, data, diggingLevel, toolLevel){
    // coords - объект, содержащий координаты разрушенного блока - {x: , y: , z: } - coords.x, coords.y, coords.z
    // id, data - id и data блока, id всегда совпадает с тем, на который была зарегистрирована функция и нужно, если одинаковая функция регистрируется на разные блоки
    // diggingLevel - уровень ломания блока, где рука или инструмент другого типа - 0. Если же инструмент совпадает с материалом блока, то уровень будет равен уровню инструмента
    // toolLevel -  уровень инструмента в руке, не зависит от самого блока

    // если блок что то дропает, эта функция должна вернуть массив из предметов, которые надо дропнуть, каждый предмет имеет формат [id, count, data]
}
```

Пример:

```js
Block.registerDropFunction("testBlock", function(coords, id, data, diggingLevel, toolLevel){
    return [[id, 1, data], [264, 1, 0]]; // дропнуть сам блок и алмаз
});

// Полный аналог предыдущей функции, но с числовым id
Block.registerDropFunctionForID(BlockID.testBlock, function(coords, id, data, diggingLevel, toolLevel){ 
    return [[id, 1, data], [264, 1, 0]]; // дропнуть сам блок и алмаз
});
```

## ФУНКЦИЯ УСТАНОВКИ:

К конкретному блоку можно привязать функцию установки, которая выполняется при установке блока с данным id. Если функция зарегистрирована, то вместо стандартной установки блока на потенциальные координаты вызовется она, а из руки отнимется 1 блок. Делается это с помощью функций Block.`registerPlaceFunction("строковый id блока", функция установки)` и Block.`registerPlaceFunctionForID(числовой id блока, функция установки)`.

Функция установки имеет такой формат:

```js
function(coords, item, block){
    // coords - объект, содержащий координаты блока, на который было произведено нажатие - {x: , y: , z: } - coords.x, coords.y, coords.z
    // coords.relative - объект, содержащий потенциальные координаты установки - {x: , y: , z: } - coords.relative.x, coords.relative.y, coords.relative.z
    // item - объект, содержащий предмет в руке игрока - {id: , count: , data: } - item.id, item.count, item.data
    // block - блок, на который было произведено нажатие.

    // если функция произвела установку основного блока на координаты, отличающиеся от coords.relative, то она должна вернуть их в формате {x: , y: , z: }
}
```

Пример:

```js
Block.registerPlaceFunction("testBlock", function(coords, item, block){
    World.setBlock(coords.relative.x, coords.relative.y, coords.relative.z, item.id, item.data); // установим наш блок
    World.setBlock(coords.relative.x, coords.relative.y + 1, coords.relative.z, item.id, item.data); // над ним установим алмазный блок
});

// Полный аналог предыдущей функции, но с числовым id
Block.registerPlaceFunctionForID(BlockID.testBlock, function(coords, item, block){
    World.setBlock(coords.relative.x, coords.relative.y, coords.relative.z, item.id, item.data); // установим наш блок
    World.setBlock(coords.relative.x, coords.relative.y + 1, coords.relative.z, item.id, item.data); // над ним установим алмазный блок
});
```

## УСТАНОВКА ФОРМЫ

Блоку с конкретным id и data можно установить форму, отличную от кубической. Для этого используется функция `Block.setBlockShape(числовой id, {x: , y: , z: }, {x: , y: , z: }, data)` - принимает `id` блока, координаты начала и координаты конца, а так же, если вы хотите сделать это для конкретной вариации блока, то определите последний параметр. Координаты в блоке могут быть от 0 до 1, стандартный блок имеет форму (0, 0, 0) - (1, 1, 1)

```js
Block.setBlockShape(BlockID.testBlock, {x: 0.2, y: 0, z: 0.2}, {x: 0.8, y: 1, z: 0.8}) // установить всем вариациям форму столба
```

## УСТАНОВКА СВОЙСТВ ПРЕДМЕТОВ

Для установки свойств предметов используется функция `Item.describeItem("строковый id", объект описания)`. 

Все параметры в объекте описания, их стандартные значения и описание:

```js
{
    category: 0, // категория в креативе
    enchant: {value: 0, type: 0}, // тип зачарования
    toolRender: false, // рендер в руке, как инструмент
    maxDamage: 0, // максимальный дамаг предмета (шкала прочности)
    stackByData: false, // стакается по data
    properties: {}, // родной объект параметров MCPE
    useAnimation: 0 // анимация использозвания
}
```

## Функции - аналоги параметров:

`Item.setCategory(id, category)` - аналог параметра category
`Item.setEnchantType(id, enchant, value)` - аналог параметра enchant
`Item.setToolRender(id, enabled)` - аналог параметра toolRender
`Item.setMaxDamage(id, maxdamage)` - аналог параметра maxDamage
`Item.setStackedByData(id, enabled)` - аналог параметра stackByData
`Item.setProperties(id, props)` - аналог параметра properties
`Item.setUseAnimation(id, animType)` - аналог параметра useAnimation

## Функции - получение параметров:

`Item.getName(id, data, encode)` - отдает имя предмета или блока с данным id и data, если encode true, то возвращает его в формате item.имя.name или block.имя.name
`Item.getMaxDamage(id)` - отдает максимальный дамаг предмета
Item.getMaxStack(id) - отдает размер стака
`Item.getUseAnimation(id)` - отдает анимацию использования

`Item.isValid(id, data)` - возвращает, существует ли данный предмет
`Item.isNativeItem(id)` - возвращает, является ли этот предмет предметом из MCPE, а не из модов


## ФУНКЦИЯ ИСПОЛЬЗОВАНИЯ ПРЕДМЕТА

К конкретному предмету можно привязать функцию использования, которая выполняется при использовании предмета с данным id. Делается это с помощью функций `Item.registerPlaceFunction("строковый id предмета", функция использования)` и `Item.registerPlaceFunctionForID(числовой id предмета, функция использования)`.

Функция использования имеет такой формат:

```js
function(coords, item, block){
    // coords - объект, содержащий координаты блока, на который было произведено нажатие - {x: , y: , z: } - coords.x, coords.y, coords.z
    // coords.relative - объект, содержащий потенциальные координаты установки блока - {x: , y: , z: } - coords.relative.x, coords.relative.y, coords.relative.z
    // item - объект, содержащий предмет в руке игрока - {id: , count: , data: } - item.id, item.count, item.data
    // block - блок, на который было произведено нажатие.
}
```

## ФУНКЦИЯ БРОСКА ПРЕДМЕТА

К конкретному предмету можно привязать функцию, которая выполняется при разбивании брошенного предмета с данным id. Делается это с помощью функций `Item.registerThrowableFunction("строковый id предмета", функция разбивания)` и `Item.registerThrowableFunctionForID(числовой id предмета, функция разбивания)`.

Функция разбивания имеет такой формат:

```js
function(projectile, item, target){
    // projectile - entity кинутого предмета
    // target - объект, содержащий координаты цели, а так же entity цели, если она является мобом - {x: , y: , z: } - target.x, target.y, target.z и target.entity
    // item - объект, содержащий предмет, который был брошен - {id: , count: , data: } - item.id, item.count, item.data
}
```
